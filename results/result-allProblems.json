{"version":"3","listProblem":[{
  "tool": "Code Inspection",
  "category": "Class structure",
  "type": "Method returns per-class constant",
  "severity": "High",
  "comment": "Method `getRewardType()` and all its derivables always return constants",
  "detailsInfo": "Reports methods that only return a constant, which may differ for various inheritors.\n\nAvailable only from **Code \\| Inspect Code** or\n**Code \\| Analyze Code \\| Run Inspection by Name** and isn't reported in the editor.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/fr/lataverne/votereward/objects/rewards/Reward.java",
      "language": "JAVA",
      "line": 52,
      "offset": 36,
      "length": 13,
      "code": {
        "startLine": 50,
        "length": 13,
        "offset": 42,
        "surroundingCode": "    }\n\n    protected abstract ERewardType getRewardType();\n\n    protected abstract @NotNull JsonElement toJsonReward();"
      }
    }
  ],
  "attributes": {
    "module": "VoteReward",
    "inspectionName": "MethodReturnAlwaysConstant"
  },
  "hash": "daa70938c4222d56b8ef34a242bab541c08b791bf597dc7512afe071031e43cc"
},{
  "tool": "Code Inspection",
  "category": "Class structure",
  "type": "Method returns per-class constant",
  "severity": "High",
  "comment": "Method `getRewardType()` and all its derivables always return constants",
  "detailsInfo": "Reports methods that only return a constant, which may differ for various inheritors.\n\nAvailable only from **Code \\| Inspect Code** or\n**Code \\| Analyze Code \\| Run Inspection by Name** and isn't reported in the editor.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/fr/lataverne/votereward/objects/rewards/ItemRewardItem.java",
      "language": "JAVA",
      "line": 36,
      "offset": 27,
      "length": 13,
      "code": {
        "startLine": 34,
        "length": 13,
        "offset": 41,
        "surroundingCode": "\n    @Override\n    protected ERewardType getRewardType() {\n        return ERewardType.ItemReward;\n    }"
      }
    }
  ],
  "attributes": {
    "module": "VoteReward",
    "inspectionName": "MethodReturnAlwaysConstant"
  },
  "hash": "82bd9d6225fbbc7498b4b59266d175a437e550e335c8b5890e5bbf73a33e9c43"
},{
  "tool": "Code Inspection",
  "category": "Class structure",
  "type": "Method returns per-class constant",
  "severity": "High",
  "comment": "Method `getRewardType()` and all its derivables always return constants",
  "detailsInfo": "Reports methods that only return a constant, which may differ for various inheritors.\n\nAvailable only from **Code \\| Inspect Code** or\n**Code \\| Analyze Code \\| Run Inspection by Name** and isn't reported in the editor.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/fr/lataverne/votereward/objects/rewards/MinecraftItem.java",
      "language": "JAVA",
      "line": 29,
      "offset": 27,
      "length": 13,
      "code": {
        "startLine": 27,
        "length": 13,
        "offset": 41,
        "surroundingCode": "\n    @Override\n    protected ERewardType getRewardType() {\n        return ERewardType.Minecraft;\n    }"
      }
    }
  ],
  "attributes": {
    "module": "VoteReward",
    "inspectionName": "MethodReturnAlwaysConstant"
  },
  "hash": "82950d66df6e425b4fbcd35bbe2bed4115e98bd9ff2db569d95477cb868a13c9"
},{
  "tool": "Code Inspection",
  "category": "Declaration redundancy",
  "type": "Method returns the same value",
  "severity": "High",
  "comment": "All implementations of this method always return `true`",
  "detailsInfo": "Reports methods and method hierarchies in which the return value always appears to be the same constant.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/fr/lataverne/votereward/commands/ConfirmableCommand.java",
      "language": "JAVA",
      "line": 36,
      "offset": 32,
      "length": 12,
      "code": {
        "startLine": 34,
        "length": 12,
        "offset": 38,
        "surroundingCode": "    }\n\n    protected abstract boolean toBeExecuted(@NotNull CommandSender sender, @NotNull String label, @NotNull List<String> args);\n\n    protected abstract boolean validate(@NotNull CommandSender sender, @NotNull String label, @NotNull List<String> args);"
      }
    }
  ],
  "attributes": {
    "module": "VoteReward",
    "inspectionName": "SameReturnValue"
  },
  "hash": "613a744815009ae03371af2b43fdb2fa3661dc86e6156c9f8745484152e653e0"
},{
  "tool": "Code Inspection",
  "category": "Embedded",
  "type": "Abstract class with a single direct inheritor",
  "severity": "High",
  "comment": "Abstract class `Gui` has only one direct inheritor",
  "detailsInfo": "Reports abstract classes that have precisely one direct inheritor. While such classes may offer admirable clarity of design, in memory-constrained or bandwidth-limited environments, they needlessly increase the total footprint of the application. Consider merging the abstract class with its inheritor.\n\n\nThis inspection is intended for Java ME and other highly resource constrained environments.\nApplying the results of this inspection without consideration might have negative effects on code clarity and design.\n\n**Example:**\n\n\n      abstract class Base {} // will be reported\n\n      class Inheritor extends Base {}\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/fr/lataverne/votereward/gui/Gui.java",
      "language": "JAVA",
      "line": 16,
      "offset": 23,
      "length": 3,
      "code": {
        "startLine": 14,
        "length": 3,
        "offset": 77,
        "surroundingCode": "\n@SuppressWarnings(\"ClassNamePrefixedWithPackageName\")\npublic abstract class Gui {\n\n    protected final ItemStack[] content;"
      }
    }
  ],
  "attributes": {
    "module": "VoteReward",
    "inspectionName": "AbstractClassWithOnlyOneDirectInheritor"
  },
  "hash": "01d2fedadfc3d7651dc61d0fe6f62dc133962eb1cb64d8a3a04cc98ce549b01e"
},{
  "tool": "Code Inspection",
  "category": "Embedded",
  "type": "Abstract class with a single direct inheritor",
  "severity": "High",
  "comment": "Abstract class `ConfirmableCommand` has only one direct inheritor",
  "detailsInfo": "Reports abstract classes that have precisely one direct inheritor. While such classes may offer admirable clarity of design, in memory-constrained or bandwidth-limited environments, they needlessly increase the total footprint of the application. Consider merging the abstract class with its inheritor.\n\n\nThis inspection is intended for Java ME and other highly resource constrained environments.\nApplying the results of this inspection without consideration might have negative effects on code clarity and design.\n\n**Example:**\n\n\n      abstract class Base {} // will be reported\n\n      class Inheritor extends Base {}\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/fr/lataverne/votereward/commands/ConfirmableCommand.java",
      "language": "JAVA",
      "line": 8,
      "offset": 23,
      "length": 18,
      "code": {
        "startLine": 6,
        "length": 18,
        "offset": 46,
        "surroundingCode": "import java.util.List;\n\npublic abstract class ConfirmableCommand extends CompositeCommand {\n\n    private static final String CONFIRM_COMMAND_USAGE = \"[confirm-command-usage]\";"
      }
    }
  ],
  "attributes": {
    "module": "VoteReward",
    "inspectionName": "AbstractClassWithOnlyOneDirectInheritor"
  },
  "hash": "fc7cde9d4179496ea8ae65926676ece85380db44cb06de38956d6df514dc6f7a"
},{
  "tool": "Code Inspection",
  "category": "Embedded",
  "type": "Interface with a single direct inheritor",
  "severity": "High",
  "comment": "Interface `DynamicCommand` has only one direct inheritor",
  "detailsInfo": "Reports interfaces that have precisely one direct inheritor. While such interfaces may offer admirable clarity of design, in memory-constrained or bandwidth-limited environments, they needlessly increase the total footprint of the application. Consider merging the interface with its inheritor.\n\n\nThis inspection is intended for Java ME and other highly resource constrained environments.\nApplying the results of this inspection without consideration might have negative effects on code clarity and design.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/fr/lataverne/votereward/commands/DynamicCommand.java",
      "language": "JAVA",
      "line": 4,
      "offset": 18,
      "length": 14,
      "code": {
        "startLine": 2,
        "length": 14,
        "offset": 39,
        "surroundingCode": "\n@FunctionalInterface\npublic interface DynamicCommand {\n\n    boolean isDynamicCommand(String label);"
      }
    }
  ],
  "attributes": {
    "module": "VoteReward",
    "inspectionName": "InterfaceWithOnlyOneDirectInheritor"
  },
  "hash": "91fe2af58d01350f28dc8130a0f3045f45dd981cadca3ff405dd4b18af047cd6"
},{
  "tool": "Code Inspection",
  "category": "Declaration redundancy",
  "type": "Unused library",
  "severity": "High",
  "comment": "Unused library 'Maven: com.google.guava:listenablefuture:9999.0-empty-to-avoid-conflict-with-guava'",
  "detailsInfo": "Reports libraries attached to the specified inspection scope that are not used directly in code.",
  "sources": [
    {
      "type": "module",
      "path": "",
      "language": "",
      "line": 0,
      "offset": 0,
      "length": 0,
      "code": {
        "startLine": 0,
        "length": 0,
        "offset": 0,
        "surroundingCode": ""
      }
    }
  ],
  "attributes": {
    "module": "VoteReward",
    "inspectionName": "UnusedLibrary"
  },
  "hash": "79ebd945528280edb65635043a3b5f4413eec3ffa6fc2b64b5e504f63f25b21e"
},{
  "tool": "Code Inspection",
  "category": "Declaration redundancy",
  "type": "Unused library",
  "severity": "High",
  "comment": "Unused library 'Maven: com.google.code.findbugs:jsr305:3.0.2'",
  "detailsInfo": "Reports libraries attached to the specified inspection scope that are not used directly in code.",
  "sources": [
    {
      "type": "module",
      "path": "",
      "language": "",
      "line": 0,
      "offset": 0,
      "length": 0,
      "code": {
        "startLine": 0,
        "length": 0,
        "offset": 0,
        "surroundingCode": ""
      }
    }
  ],
  "attributes": {
    "module": "VoteReward",
    "inspectionName": "UnusedLibrary"
  },
  "hash": "d7c30756b5a53de784896d4c5f8fa050b32c0e6aa84b1e7f9e03c0c243a633a7"
},{
  "tool": "Code Inspection",
  "category": "Declaration redundancy",
  "type": "Unused declaration",
  "severity": "High",
  "comment": "Method is never used.",
  "detailsInfo": "Reports classes, methods, or fields in the specified inspection scope that are not used or unreachable from entry points.\n\nAn entry point can be the main method, tests, classes mentioned outside the specified scope, classes accessible from\n`module-info.java`, and so on. You can also configure custom entry points by using name patterns or annotations.\n\n**Example:**\n\n\n      public class Department {\n        private Organization myOrganization;\n      }\n\nIn this example, `Department` explicitly references `Organization` but if `Department` class itself is unused, then inspection will report both classes.\n\n\nThe inspection also reports parameters that are not used by their methods and all method implementations and overriders, as well as local\nvariables that are declared but not used.\n\n\n**Note:** Some unused members may not be reported during in-editor code highlighting. For performance reasons, a non-private member is\nchecked only when its name rarely occurs in the project.\nTo see all results, run the inspection by selecting **Code \\| Inspect Code** or **Code \\| Analyze Code \\| Run Inspection by Name** from the main menu.\n\nUse the visibility settings below to configure members to be reported. For example, configuring report `private` methods only means\nthat `public` methods of `private` inner class will be reported but `protected` methods of top level class\nwill be ignored.\n\n\nUse the **entry points** tab to configure entry points to be considered during the inspection run.\n\nYou can add entry points manually when inspection results are ready.\n\nIf your code uses unsupported frameworks, there are several options:\n\n* If the framework relies on annotations, use the **Annotations...** button to configure the framework's annotations.\n* If the framework doesn't rely on annotations, try to configure class name patterns that are expected by the framework.\n\nThis way the annotated code accessible by the framework internals will be treated as used.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/fr/lataverne/votereward/Helper.java",
      "language": "",
      "line": 91,
      "offset": 26,
      "length": 18,
      "code": {
        "startLine": 89,
        "length": 18,
        "offset": 32,
        "surroundingCode": "    }\n\n    public static String getMessageOnConfig(final String path) {\n        String entirePath = path;\n        if (!entirePath.startsWith(\"message.\")) {"
      }
    }
  ],
  "attributes": {
    "module": "VoteReward",
    "inspectionName": "unused"
  },
  "hash": "f8b9e4d9c440fddb1619d28ef18c1d2728231cec8f318934111fd7e59ddafc34"
},{
  "tool": "Code Inspection",
  "category": "Declaration redundancy",
  "type": "Unused declaration",
  "severity": "High",
  "comment": "Method is never used.",
  "detailsInfo": "Reports classes, methods, or fields in the specified inspection scope that are not used or unreachable from entry points.\n\nAn entry point can be the main method, tests, classes mentioned outside the specified scope, classes accessible from\n`module-info.java`, and so on. You can also configure custom entry points by using name patterns or annotations.\n\n**Example:**\n\n\n      public class Department {\n        private Organization myOrganization;\n      }\n\nIn this example, `Department` explicitly references `Organization` but if `Department` class itself is unused, then inspection will report both classes.\n\n\nThe inspection also reports parameters that are not used by their methods and all method implementations and overriders, as well as local\nvariables that are declared but not used.\n\n\n**Note:** Some unused members may not be reported during in-editor code highlighting. For performance reasons, a non-private member is\nchecked only when its name rarely occurs in the project.\nTo see all results, run the inspection by selecting **Code \\| Inspect Code** or **Code \\| Analyze Code \\| Run Inspection by Name** from the main menu.\n\nUse the visibility settings below to configure members to be reported. For example, configuring report `private` methods only means\nthat `public` methods of `private` inner class will be reported but `protected` methods of top level class\nwill be ignored.\n\n\nUse the **entry points** tab to configure entry points to be considered during the inspection run.\n\nYou can add entry points manually when inspection results are ready.\n\nIf your code uses unsupported frameworks, there are several options:\n\n* If the framework relies on annotations, use the **Annotations...** button to configure the framework's annotations.\n* If the framework doesn't rely on annotations, try to configure class name patterns that are expected by the framework.\n\nThis way the annotated code accessible by the framework internals will be treated as used.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/fr/lataverne/votereward/Helper.java",
      "language": "",
      "line": 105,
      "offset": 26,
      "length": 20,
      "code": {
        "startLine": 103,
        "length": 20,
        "offset": 53,
        "surroundingCode": "\n    @Contract(pure = true)\n    public static String replaceValueInString(final String str, final String @NotNull ... args) {\n        String output = str;\n        int nbArg = args.length;"
      }
    }
  ],
  "attributes": {
    "module": "VoteReward",
    "inspectionName": "unused"
  },
  "hash": "27bb87ef3c5f89e7673827e0bcdab83bf4963a0271ae24fd3224a1ca6b420563"
},{
  "tool": "Code Inspection",
  "category": "Declaration redundancy",
  "type": "Unused declaration",
  "severity": "High",
  "comment": "Parameter `sender` is not used in either this method or any of its derived methods",
  "detailsInfo": "Reports classes, methods, or fields in the specified inspection scope that are not used or unreachable from entry points.\n\nAn entry point can be the main method, tests, classes mentioned outside the specified scope, classes accessible from\n`module-info.java`, and so on. You can also configure custom entry points by using name patterns or annotations.\n\n**Example:**\n\n\n      public class Department {\n        private Organization myOrganization;\n      }\n\nIn this example, `Department` explicitly references `Organization` but if `Department` class itself is unused, then inspection will report both classes.\n\n\nThe inspection also reports parameters that are not used by their methods and all method implementations and overriders, as well as local\nvariables that are declared but not used.\n\n\n**Note:** Some unused members may not be reported during in-editor code highlighting. For performance reasons, a non-private member is\nchecked only when its name rarely occurs in the project.\nTo see all results, run the inspection by selecting **Code \\| Inspect Code** or **Code \\| Analyze Code \\| Run Inspection by Name** from the main menu.\n\nUse the visibility settings below to configure members to be reported. For example, configuring report `private` methods only means\nthat `public` methods of `private` inner class will be reported but `protected` methods of top level class\nwill be ignored.\n\n\nUse the **entry points** tab to configure entry points to be considered during the inspection run.\n\nYou can add entry points manually when inspection results are ready.\n\nIf your code uses unsupported frameworks, there are several options:\n\n* If the framework relies on annotations, use the **Annotations...** button to configure the framework's annotations.\n* If the framework doesn't rely on annotations, try to configure class name patterns that are expected by the framework.\n\nThis way the annotated code accessible by the framework internals will be treated as used.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/fr/lataverne/votereward/commands/CompositeCommand.java",
      "language": "JAVA",
      "line": 273,
      "offset": 72,
      "length": 6,
      "code": {
        "startLine": 271,
        "length": 6,
        "offset": 109,
        "surroundingCode": "    protected abstract void setup();\n\n    protected @NotNull List<String> tabComplete(@NotNull CommandSender sender, @NotNull String label, @NotNull List<String> args) {\n        return new ArrayList<>();\n    }"
      }
    }
  ],
  "attributes": {
    "module": "VoteReward",
    "inspectionName": "unused"
  },
  "hash": "edbc37801c0735b26f01fe64d18f7606e6cc9db8b2fe0f882f2afac6b8a70eea"
},{
  "tool": "Code Inspection",
  "category": "Declaration redundancy",
  "type": "Unused declaration",
  "severity": "High",
  "comment": "Parameter `label` is not used in either this method or any of its derived methods",
  "detailsInfo": "Reports classes, methods, or fields in the specified inspection scope that are not used or unreachable from entry points.\n\nAn entry point can be the main method, tests, classes mentioned outside the specified scope, classes accessible from\n`module-info.java`, and so on. You can also configure custom entry points by using name patterns or annotations.\n\n**Example:**\n\n\n      public class Department {\n        private Organization myOrganization;\n      }\n\nIn this example, `Department` explicitly references `Organization` but if `Department` class itself is unused, then inspection will report both classes.\n\n\nThe inspection also reports parameters that are not used by their methods and all method implementations and overriders, as well as local\nvariables that are declared but not used.\n\n\n**Note:** Some unused members may not be reported during in-editor code highlighting. For performance reasons, a non-private member is\nchecked only when its name rarely occurs in the project.\nTo see all results, run the inspection by selecting **Code \\| Inspect Code** or **Code \\| Analyze Code \\| Run Inspection by Name** from the main menu.\n\nUse the visibility settings below to configure members to be reported. For example, configuring report `private` methods only means\nthat `public` methods of `private` inner class will be reported but `protected` methods of top level class\nwill be ignored.\n\n\nUse the **entry points** tab to configure entry points to be considered during the inspection run.\n\nYou can add entry points manually when inspection results are ready.\n\nIf your code uses unsupported frameworks, there are several options:\n\n* If the framework relies on annotations, use the **Annotations...** button to configure the framework's annotations.\n* If the framework doesn't rely on annotations, try to configure class name patterns that are expected by the framework.\n\nThis way the annotated code accessible by the framework internals will be treated as used.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/fr/lataverne/votereward/commands/CompositeCommand.java",
      "language": "JAVA",
      "line": 273,
      "offset": 96,
      "length": 5,
      "code": {
        "startLine": 271,
        "length": 5,
        "offset": 133,
        "surroundingCode": "    protected abstract void setup();\n\n    protected @NotNull List<String> tabComplete(@NotNull CommandSender sender, @NotNull String label, @NotNull List<String> args) {\n        return new ArrayList<>();\n    }"
      }
    }
  ],
  "attributes": {
    "module": "VoteReward",
    "inspectionName": "unused"
  },
  "hash": "016f8f4910fce155868f6e6469a7827e78ba166845a25d84320903d53a267009"
},{
  "tool": "Code Inspection",
  "category": "Declaration redundancy",
  "type": "Unused declaration",
  "severity": "High",
  "comment": "Parameter `label` is not used in any implementation",
  "detailsInfo": "Reports classes, methods, or fields in the specified inspection scope that are not used or unreachable from entry points.\n\nAn entry point can be the main method, tests, classes mentioned outside the specified scope, classes accessible from\n`module-info.java`, and so on. You can also configure custom entry points by using name patterns or annotations.\n\n**Example:**\n\n\n      public class Department {\n        private Organization myOrganization;\n      }\n\nIn this example, `Department` explicitly references `Organization` but if `Department` class itself is unused, then inspection will report both classes.\n\n\nThe inspection also reports parameters that are not used by their methods and all method implementations and overriders, as well as local\nvariables that are declared but not used.\n\n\n**Note:** Some unused members may not be reported during in-editor code highlighting. For performance reasons, a non-private member is\nchecked only when its name rarely occurs in the project.\nTo see all results, run the inspection by selecting **Code \\| Inspect Code** or **Code \\| Analyze Code \\| Run Inspection by Name** from the main menu.\n\nUse the visibility settings below to configure members to be reported. For example, configuring report `private` methods only means\nthat `public` methods of `private` inner class will be reported but `protected` methods of top level class\nwill be ignored.\n\n\nUse the **entry points** tab to configure entry points to be considered during the inspection run.\n\nYou can add entry points manually when inspection results are ready.\n\nIf your code uses unsupported frameworks, there are several options:\n\n* If the framework relies on annotations, use the **Annotations...** button to configure the framework's annotations.\n* If the framework doesn't rely on annotations, try to configure class name patterns that are expected by the framework.\n\nThis way the annotated code accessible by the framework internals will be treated as used.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/fr/lataverne/votereward/commands/ConfirmableCommand.java",
      "language": "JAVA",
      "line": 36,
      "offset": 92,
      "length": 5,
      "code": {
        "startLine": 34,
        "length": 5,
        "offset": 98,
        "surroundingCode": "    }\n\n    protected abstract boolean toBeExecuted(@NotNull CommandSender sender, @NotNull String label, @NotNull List<String> args);\n\n    protected abstract boolean validate(@NotNull CommandSender sender, @NotNull String label, @NotNull List<String> args);"
      }
    }
  ],
  "attributes": {
    "module": "VoteReward",
    "inspectionName": "unused"
  },
  "hash": "c8b73570d865dc38c4f2c6f6a6da4b920335bb2cae4a777ee8cd5130f50b5f22"
},{
  "tool": "Code Inspection",
  "category": "Declaration redundancy",
  "type": "Unused declaration",
  "severity": "High",
  "comment": "Parameter `label` is not used in any implementation",
  "detailsInfo": "Reports classes, methods, or fields in the specified inspection scope that are not used or unreachable from entry points.\n\nAn entry point can be the main method, tests, classes mentioned outside the specified scope, classes accessible from\n`module-info.java`, and so on. You can also configure custom entry points by using name patterns or annotations.\n\n**Example:**\n\n\n      public class Department {\n        private Organization myOrganization;\n      }\n\nIn this example, `Department` explicitly references `Organization` but if `Department` class itself is unused, then inspection will report both classes.\n\n\nThe inspection also reports parameters that are not used by their methods and all method implementations and overriders, as well as local\nvariables that are declared but not used.\n\n\n**Note:** Some unused members may not be reported during in-editor code highlighting. For performance reasons, a non-private member is\nchecked only when its name rarely occurs in the project.\nTo see all results, run the inspection by selecting **Code \\| Inspect Code** or **Code \\| Analyze Code \\| Run Inspection by Name** from the main menu.\n\nUse the visibility settings below to configure members to be reported. For example, configuring report `private` methods only means\nthat `public` methods of `private` inner class will be reported but `protected` methods of top level class\nwill be ignored.\n\n\nUse the **entry points** tab to configure entry points to be considered during the inspection run.\n\nYou can add entry points manually when inspection results are ready.\n\nIf your code uses unsupported frameworks, there are several options:\n\n* If the framework relies on annotations, use the **Annotations...** button to configure the framework's annotations.\n* If the framework doesn't rely on annotations, try to configure class name patterns that are expected by the framework.\n\nThis way the annotated code accessible by the framework internals will be treated as used.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/fr/lataverne/votereward/commands/ConfirmableCommand.java",
      "language": "JAVA",
      "line": 38,
      "offset": 88,
      "length": 5,
      "code": {
        "startLine": 36,
        "length": 5,
        "offset": 215,
        "surroundingCode": "    protected abstract boolean toBeExecuted(@NotNull CommandSender sender, @NotNull String label, @NotNull List<String> args);\n\n    protected abstract boolean validate(@NotNull CommandSender sender, @NotNull String label, @NotNull List<String> args);\n}\n"
      }
    }
  ],
  "attributes": {
    "module": "VoteReward",
    "inspectionName": "unused"
  },
  "hash": "b810ec2de65a5a68a42332b691cc3f247ec4860810698a2bd2d20fe6aca0c16d"
},{
  "tool": "Code Inspection",
  "category": "Declaration redundancy",
  "type": "Unused declaration",
  "severity": "High",
  "comment": "* Method owner class is never instantiated OR\n* An instantiation is not reachable from entry points.",
  "detailsInfo": "Reports classes, methods, or fields in the specified inspection scope that are not used or unreachable from entry points.\n\nAn entry point can be the main method, tests, classes mentioned outside the specified scope, classes accessible from\n`module-info.java`, and so on. You can also configure custom entry points by using name patterns or annotations.\n\n**Example:**\n\n\n      public class Department {\n        private Organization myOrganization;\n      }\n\nIn this example, `Department` explicitly references `Organization` but if `Department` class itself is unused, then inspection will report both classes.\n\n\nThe inspection also reports parameters that are not used by their methods and all method implementations and overriders, as well as local\nvariables that are declared but not used.\n\n\n**Note:** Some unused members may not be reported during in-editor code highlighting. For performance reasons, a non-private member is\nchecked only when its name rarely occurs in the project.\nTo see all results, run the inspection by selecting **Code \\| Inspect Code** or **Code \\| Analyze Code \\| Run Inspection by Name** from the main menu.\n\nUse the visibility settings below to configure members to be reported. For example, configuring report `private` methods only means\nthat `public` methods of `private` inner class will be reported but `protected` methods of top level class\nwill be ignored.\n\n\nUse the **entry points** tab to configure entry points to be considered during the inspection run.\n\nYou can add entry points manually when inspection results are ready.\n\nIf your code uses unsupported frameworks, there are several options:\n\n* If the framework relies on annotations, use the **Annotations...** button to configure the framework's annotations.\n* If the framework doesn't rely on annotations, try to configure class name patterns that are expected by the framework.\n\nThis way the annotated code accessible by the framework internals will be treated as used.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/fr/lataverne/votereward/gui/RewardGroupStatsView.java",
      "language": "",
      "line": 13,
      "offset": 28,
      "length": 8,
      "code": {
        "startLine": 11,
        "length": 8,
        "offset": 42,
        "surroundingCode": "\n    @Override\n    public @NotNull String getTitle() {\n        return Helper.getStringInConfig(\"gui.stat.title\");\n    }"
      }
    }
  ],
  "attributes": {
    "module": "VoteReward",
    "inspectionName": "unused"
  },
  "hash": "76f2c0bad5e2c728ec7a90a1c72c0046d281566cbff32fedfa611a70f11af613"
},{
  "tool": "Code Inspection",
  "category": "Declaration redundancy",
  "type": "Unused declaration",
  "severity": "High",
  "comment": "Method is never used.",
  "detailsInfo": "Reports classes, methods, or fields in the specified inspection scope that are not used or unreachable from entry points.\n\nAn entry point can be the main method, tests, classes mentioned outside the specified scope, classes accessible from\n`module-info.java`, and so on. You can also configure custom entry points by using name patterns or annotations.\n\n**Example:**\n\n\n      public class Department {\n        private Organization myOrganization;\n      }\n\nIn this example, `Department` explicitly references `Organization` but if `Department` class itself is unused, then inspection will report both classes.\n\n\nThe inspection also reports parameters that are not used by their methods and all method implementations and overriders, as well as local\nvariables that are declared but not used.\n\n\n**Note:** Some unused members may not be reported during in-editor code highlighting. For performance reasons, a non-private member is\nchecked only when its name rarely occurs in the project.\nTo see all results, run the inspection by selecting **Code \\| Inspect Code** or **Code \\| Analyze Code \\| Run Inspection by Name** from the main menu.\n\nUse the visibility settings below to configure members to be reported. For example, configuring report `private` methods only means\nthat `public` methods of `private` inner class will be reported but `protected` methods of top level class\nwill be ignored.\n\n\nUse the **entry points** tab to configure entry points to be considered during the inspection run.\n\nYou can add entry points manually when inspection results are ready.\n\nIf your code uses unsupported frameworks, there are several options:\n\n* If the framework relies on annotations, use the **Annotations...** button to configure the framework's annotations.\n* If the framework doesn't rely on annotations, try to configure class name patterns that are expected by the framework.\n\nThis way the annotated code accessible by the framework internals will be treated as used.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/fr/lataverne/votereward/managers/GuiManager.java",
      "language": "",
      "line": 52,
      "offset": 33,
      "length": 23,
      "code": {
        "startLine": 50,
        "length": 23,
        "offset": 39,
        "surroundingCode": "    }\n\n    public RewardGroupStatsView getRewardGroupStatsView(@NotNull Player player, int page) {\n        Gui gui = this.getGui(player.getUniqueId());\n"
      }
    }
  ],
  "attributes": {
    "module": "VoteReward",
    "inspectionName": "unused"
  },
  "hash": "45a4078811dd5b004bbacc546d7d7c78d859368d19f31dcc2b98cc8ac0334163"
},{
  "tool": "Code Inspection",
  "category": "Declaration redundancy",
  "type": "Actual method parameter is the same constant",
  "severity": "High",
  "comment": "Actual value of parameter 'label' is always 'delete'",
  "detailsInfo": "Reports methods in which a parameter appears to always be the same constant.\n\nExample:\n\n\n      static void printPoint(int x, int y) { // x is always 0\n        System.out.println(x + \", \" + y);\n      }\n\n      public static void main(String[] args) {\n        printPoint(0, 1);\n        printPoint(0, 2);\n      }\n\nThe quick-fix inlines the constant value. This may simplify the method implementation.\n\n\nUse the **Ignore when inline parameter initializer would not succeed** option to suppress the inspections when:\n\n* the parameter is modified inside the method.\n* the parameter value that is being passed is a reference to an inaccessible field (only in Java).\n* the parameter is a vararg (only in Java).\n\n\nUse the **Maximal reported method visibility** option to control the maximum visibility of methods to be reported.\n\n\nUse the **Minimal reported method usage count** field to specify the minimal number of method usages with the same parameter value.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/fr/lataverne/votereward/commands/ConfirmableCommand.java",
      "language": "JAVA",
      "line": 12,
      "offset": 75,
      "length": 5,
      "code": {
        "startLine": 10,
        "length": 5,
        "offset": 158,
        "surroundingCode": "    private static final String CONFIRM_COMMAND_USAGE = \"[confirm-command-usage]\";\n\n    protected ConfirmableCommand(@NotNull CompositeCommand parent, String label, String... aliases) {\n        super(parent, label, aliases);\n    }"
      }
    }
  ],
  "attributes": {
    "module": "VoteReward",
    "inspectionName": "SameParameterValue"
  },
  "hash": "36cac9d51afdd86a599a33882ae3a873d68828d49e6ed7e39d949cc74a9a6a52"
},{
  "tool": "Code Inspection",
  "category": "Declaration redundancy",
  "type": "Actual method parameter is the same constant",
  "severity": "High",
  "comment": "Actual value of parameter 'size' is always '54'",
  "detailsInfo": "Reports methods in which a parameter appears to always be the same constant.\n\nExample:\n\n\n      static void printPoint(int x, int y) { // x is always 0\n        System.out.println(x + \", \" + y);\n      }\n\n      public static void main(String[] args) {\n        printPoint(0, 1);\n        printPoint(0, 2);\n      }\n\nThe quick-fix inlines the constant value. This may simplify the method implementation.\n\n\nUse the **Ignore when inline parameter initializer would not succeed** option to suppress the inspections when:\n\n* the parameter is modified inside the method.\n* the parameter value that is being passed is a reference to an inaccessible field (only in Java).\n* the parameter is a vararg (only in Java).\n\n\nUse the **Maximal reported method visibility** option to control the maximum visibility of methods to be reported.\n\n\nUse the **Minimal reported method usage count** field to specify the minimal number of method usages with the same parameter value.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/fr/lataverne/votereward/gui/NavigableGui.java",
      "language": "JAVA",
      "line": 29,
      "offset": 32,
      "length": 4,
      "code": {
        "startLine": 27,
        "length": 4,
        "offset": 56,
        "surroundingCode": "    protected int page;\n\n    protected NavigableGui(int size, int page) {\n        super(size);\n"
      }
    }
  ],
  "attributes": {
    "module": "VoteReward",
    "inspectionName": "SameParameterValue"
  },
  "hash": "86e7e7f94716ef720c2d6b94492270b00a9be3c10404dc47e96564ee93c794ba"
},{
  "tool": "Code Inspection",
  "category": "Code style issues",
  "type": "'if' statement can be replaced with conditional or boolean expression",
  "severity": "High",
  "comment": "If statement can be replaced with '?:'",
  "detailsInfo": "Reports `if` statements that can be replaced with conditions using the `&&`, `||`, `==`, `!=`, or `?:` operator.\n\nThe result is usually shorter, but not always clearer, so it's not advised to apply the fix in every case.\n\nExample:\n\n\n      if (condition) return true; else return foo;\n\nAfter the quick-fix is applied:\n\n\n      return condition || foo;\n\nConfigure the inspection:\n\n* Use the **Don't suggest '?:' operator** option to disable the warning when the `?:` operator is suggested. In this case, only `&&`, `||`, `==`, and `!=` suggestions will be highlighted. The quick-fix will still be available in the editor.\n* Use the **Ignore chained 'if' statements** option to disable the warning for `if-else` chains. The quick-fix will still be available in the editor.\n\nNew in 2018.2",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/fr/lataverne/votereward/commands/admin/rewardsgroups/RewardsGroupListAdminCommand.java",
      "language": "JAVA",
      "line": 55,
      "offset": 17,
      "length": 2,
      "code": {
        "startLine": 53,
        "length": 2,
        "offset": 94,
        "surroundingCode": "                StringBuilder message = new StringBuilder(rewardsGroupName);\n\n                if (rewardsGroupName.equals(enabledRewardsGroup)) {\n                    message.insert(0, ChatColor.RED + \"\" + ChatColor.BOLD + \"> \");\n                } else {"
      }
    }
  ],
  "attributes": {
    "module": "VoteReward",
    "inspectionName": "SimplifiableIfStatement"
  },
  "hash": "e9d60614498cfca252000e7121bcc5a2c9dcfe897396bdef2a7a530532a7f410"
},{
  "tool": "Code Inspection",
  "category": "Code style issues",
  "type": "'if' statement can be replaced with conditional or boolean expression",
  "severity": "High",
  "comment": "If statement can be replaced with '\\&\\&'",
  "detailsInfo": "Reports `if` statements that can be replaced with conditions using the `&&`, `||`, `==`, `!=`, or `?:` operator.\n\nThe result is usually shorter, but not always clearer, so it's not advised to apply the fix in every case.\n\nExample:\n\n\n      if (condition) return true; else return foo;\n\nAfter the quick-fix is applied:\n\n\n      return condition || foo;\n\nConfigure the inspection:\n\n* Use the **Don't suggest '?:' operator** option to disable the warning when the `?:` operator is suggested. In this case, only `&&`, `||`, `==`, and `!=` suggestions will be highlighted. The quick-fix will still be available in the editor.\n* Use the **Ignore chained 'if' statements** option to disable the warning for `if-else` chains. The quick-fix will still be available in the editor.\n\nNew in 2018.2",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/fr/lataverne/votereward/commands/CompositeCommand.java",
      "language": "JAVA",
      "line": 168,
      "offset": 9,
      "length": 2,
      "code": {
        "startLine": 166,
        "length": 2,
        "offset": 127,
        "surroundingCode": "    public boolean showHelp(CommandSender sender) {\n        CompositeCommand helpCommand = this.getSubCommand(\"help\");\n        if (helpCommand != null) {\n            return helpCommand.call(sender, \"help\", new ArrayList<>());\n        } else {"
      }
    }
  ],
  "attributes": {
    "module": "VoteReward",
    "inspectionName": "SimplifiableIfStatement"
  },
  "hash": "19b2600362b2aeecd91daee2cc9f160fec95fe2da2a63a3fc3d0d19a1f3e4980"
},{
  "tool": "Code Inspection",
  "category": "Code style issues",
  "type": "'if' statement can be replaced with conditional or boolean expression",
  "severity": "High",
  "comment": "If statement can be replaced with '?:'",
  "detailsInfo": "Reports `if` statements that can be replaced with conditions using the `&&`, `||`, `==`, `!=`, or `?:` operator.\n\nThe result is usually shorter, but not always clearer, so it's not advised to apply the fix in every case.\n\nExample:\n\n\n      if (condition) return true; else return foo;\n\nAfter the quick-fix is applied:\n\n\n      return condition || foo;\n\nConfigure the inspection:\n\n* Use the **Don't suggest '?:' operator** option to disable the warning when the `?:` operator is suggested. In this case, only `&&`, `||`, `==`, and `!=` suggestions will be highlighted. The quick-fix will still be available in the editor.\n* Use the **Ignore chained 'if' statements** option to disable the warning for `if-else` chains. The quick-fix will still be available in the editor.\n\nNew in 2018.2",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/fr/lataverne/votereward/managers/CommandsManager.java",
      "language": "JAVA",
      "line": 31,
      "offset": 13,
      "length": 2,
      "code": {
        "startLine": 29,
        "length": 2,
        "offset": 103,
        "surroundingCode": "            this.commandMap = (SimpleCommandMap) commandMapField.get(Bukkit.getServer());\n\n            if (this.commandMap.register(\"votereward\", command)) {\n                VoteReward.sendMessageToConsole(\n                        ChatColor.GREEN + \"Registering the command \\\"\" + command.getLabel() + \"\\\" successful\");"
      }
    }
  ],
  "attributes": {
    "module": "VoteReward",
    "inspectionName": "SimplifiableIfStatement"
  },
  "hash": "4437f29af6de046af0a160a58d8ab8a01c99cb731267d7ce443c6faebfe3473a"
}]}